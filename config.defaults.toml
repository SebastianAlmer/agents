# ============================================================================
# Agents Runtime Defaults (projektneutral)
# ============================================================================
# Diese Datei enthaelt die globalen Standardwerte.
# Sie wird versioniert und soll NICHT projektspezifisch sein.
#
# So nutzt du sie:
# 1) config.local.example.toml nach config.local.toml kopieren.
# 2) In config.local.toml mindestens [paths].repo_root setzen.
# 3) Nur Felder ueberschreiben, die du pro Projekt wirklich brauchst.
#
# Kennzeichnung in den Kommentaren:
# - MUSS: sollte in config.local.toml gesetzt werden.
# - OPTIONAL: kann so bleiben, wenn der Default fuer dein Projekt passt.
#
# Startkommandos laufen aus dem Repo-Root:
# - node setup-project.js --repo-root /abs/path
# - node po-runner.js --mode vision|intake
# - node delivery-runner.js --mode full|fast|test
# - node reqeng-cli.js

[paths]
# MUSS: Absoluter Pfad zum Ziel-Repository, in dem die Agenten arbeiten.
repo_root = ""

# OPTIONAL: Queue-Basisordner der Requirements.
# Default zeigt auf den requirements-Ordner in diesem agents-Repo.
requirements_root = "./requirements"

# OPTIONAL: Doku-Basisordner im Ziel-Repo.
# Leer bedeutet automatisch: <repo_root>/docs
docs_dir = ""

# OPTIONAL: Produktvision-Ordner.
# Leer bedeutet automatisch: <docs_dir>/product-operating-system
product_vision_dir = ""

[loops]
# OPTIONAL: Bundle-Groesse fuer Delivery.
bundle_min_size = 5
bundle_max_size = 20

# OPTIONAL: Polling-Intervalle (Sekunden).
po_poll_seconds = 20
delivery_poll_seconds = 20

# OPTIONAL: Allgemeine Retry-Strategie fuer Runner-Script-Aufrufe.
max_retries = 3
retry_delay_seconds = 2

# OPTIONAL: Falls selected zu lange kleiner als bundle_min_size bleibt,
# startet Delivery nach N Zyklen trotzdem mit einem unterfuellten Bundle.
force_underfilled_after_cycles = 3

[delivery_runner]
# OPTIONAL: full | fast | test
# full = kompletter Delivery-Flow mit Downstream-Gates
# fast = nur selected -> arch -> dev
# test = Quality-/Regression-Mode (kein Deploy), danach Volltest ueber released
default_mode = "full"

[delivery_quality]
# OPTIONAL: true = QA/UAT sind harte Gates vor Deploy.
strict_gate = true

# OPTIONAL: Wenn true, muss QA gate PASS sein, sonst geht Bundle zurueck an DEV.
require_qa_pass = true

# OPTIONAL: Wenn true, muss UAT gate PASS sein, sonst geht Bundle zurueck an DEV.
require_uat_pass = true

# OPTIONAL: Bei Gate-Fail Bundle nach DEV routen (statt nur Follow-up Req erzeugen).
route_to_dev_on_fail = true

# OPTIONAL: Max. Anzahl QA/UAT Nachbesserungszyklen pro Bundle.
max_fix_cycles = 3

# OPTIONAL: Bei Gate-Fail trotzdem automatische Follow-up-Reqs erzeugen.
# Empfohlen: false, damit DEV erst das aktuelle Bundle sauber stabilisiert.
emit_followups_on_fail = false

[e2e]
# OPTIONAL: Deterministischer Full-E2E-Gate (z. B. Playwright/Cypress).
# Dieser Lauf ist shell-basiert und damit technologieneutral.
enabled = false

# OPTIONAL: Wenn true, dann gilt in delivery-runner --mode test:
# E2E MUSS laufen. Ist e2e deaktiviert/fehlerhaft konfiguriert, wird der Gate-Lauf als FAIL gewertet.
# Hinweis: Mit enabled=false und required_in_test_mode=true ist mode=test absichtlich nicht gruen.
required_in_test_mode = true

# OPTIONAL: Wenn true, wird beim finalen Vision-Abschluss in mode=full
# der deterministische E2E-Lauf zusaetzlich zur Agent-Regression ausgefuehrt.
run_on_full_completion = true

# OPTIONAL: Arbeitsverzeichnis fuer E2E-Kommandos.
# Leer = automatisch <repo_root>.
working_dir = ""

# OPTIONAL: Timeout pro E2E-Kommando (Sekunden).
timeout_seconds = 1800

# OPTIONAL: Vorbereitung vor dem eigentlichen Test (z. B. DB reset/migrate/seed, Build).
setup_commands = []

# OPTIONAL: Verfuegbarkeits-/Health-Pruefungen vor test_command.
healthcheck_commands = []

# OPTIONAL: Pflicht bei enabled=true.
# Hier muss der deterministische Volltest stehen (z. B. Playwright CI Command).
test_command = ""

# OPTIONAL: Aufraeumen nach dem Testlauf (wird auch nach FAIL versucht).
teardown_command = ""

# OPTIONAL: Environment-Variablen als KEY=VALUE Liste fuer alle E2E-Kommandos.
env = []

[deploy]
# OPTIONAL: check | commit | commit_push
mode = "commit_push"

# OPTIONAL: Wenn true, wird bei Erfolg final gepusht (wenn mode Push erlaubt).
final_push_on_success = true

# OPTIONAL: Wenn true, muss Git zu Beginn commit-faehiger Deploys sauber sein.
require_clean_start_for_commits = true

[deploy.pr]
# OPTIONAL: Automatische PR-Erstellung nach Deploy.
enabled = false

# OPTIONAL: github | gitlab
provider = "github"

# OPTIONAL: Remote und Base-Branch fuer PR.
remote = "origin"
base_branch = "main"

# OPTIONAL: Head-Branch-Quelle.
# current = aktueller Branch, fixed = head_branch verwenden
head_mode = "current"

# OPTIONAL: Nur relevant bei head_mode = fixed.
head_branch = ""

# OPTIONAL: PR als Draft erzeugen.
draft = false

# OPTIONAL: PR erst nach erfolgreichem Push erstellen.
create_only_after_push = true

# OPTIONAL: Verfuegbare Platzhalter:
# ${type}, ${branch}, ${base}, ${remote}
title_template = "${type}: ${branch} -> ${base}"
body_template = "Automated PR from ${branch} to ${base} after deploy bundle."

[po]
# OPTIONAL: intake | vision
default_mode = "vision"

# OPTIONAL: Sicherheitsgrenzen im Vision-Modus.
vision_max_cycles = 100
vision_max_requirements = 1000
vision_stable_cycles = 2

# OPTIONAL: Fuellstrategie fuer selected.
selected_low_watermark = 1
selected_high_watermark = 3

# OPTIONAL: Intake-Durchsatz und Loop-Schutz.
intake_max_per_cycle = 3
intake_loop_cooldown_cycles = 3
intake_idempotence_enabled = true

# OPTIONAL: Backlog-Autopromotion gegen Stau.
backlog_promote_enabled = true
backlog_promote_after_cycles = 3
backlog_promote_min_business_score = 80
backlog_promote_max_per_cycle = 2

[arch]
# OPTIONAL: always | triggered | never
routing_mode = "triggered"

# OPTIONAL: Trigger-Regeln fuer routing_mode = triggered.
require_for_scopes = ["fullstack"]
require_for_review_risks = ["high"]
require_for_review_scopes = ["qa_sec", "full"]
trigger_frontmatter_flags = ["arch_required", "needs_arch"]
trigger_keywords = [
  "auth",
  "authorization",
  "permission",
  "security",
  "secret",
  "token",
  "login",
  "password",
  "encryption",
  "privacy",
  "compliance",
  "gdpr",
  "pii",
  "payment",
  "billing",
  "migration",
  "schema",
  "database",
  "prisma",
  "webhook",
  "oauth",
  "rbac",
  "acl",
  "sso",
  "destructive"
]

# OPTIONAL: ARCH-Dokument-Digest.
digest_enabled = true
digest_file = ".runtime/arch-docs-digest.md"
digest_max_files = 12
digest_max_headings_per_file = 20

# OPTIONAL: ARCH-Retries (0 = One-Shot).
max_retries = 0

[dev_routing]
# OPTIONAL: fullstack_only | split
mode = "fullstack_only"

# OPTIONAL: Scope-Fallback, wenn implementation_scope fehlt.
default_scope = "fullstack"

[dev_agents]
# OPTIONAL: Mindestens ein Dev-Agent sollte true sein.
use_fe = false
use_be = false
use_fs = true

[dev]
# OPTIONAL: DEV-Laufzeitgrenze und Recovery-Leiter.
run_timeout_seconds = 900
same_thread_retries = 1
fresh_thread_retries = 1

[qa]
# OPTIONAL: Projektspezifische QA-Kommandos.
# Leer = QA entscheidet generisch ohne harte Kommandopflicht.
mandatory_checks = []

# OPTIONAL: true = Delivery-Runner fuehrt mandatory_checks deterministisch aus,
# bevor der QA-Agent gestartet wird (spart Tokens und ist reproduzierbar).
run_checks_in_runner = true

[models]
# OPTIONAL: Modellzuordnung pro Agent.
default = "gpt-5.3-codex-spark"
#po = "gpt-5.3-codex"
#arch = "gpt-5.3-codex"
#reqeng = "gpt-5.3-codex"
#sec = "gpt-5.3-codex"
#dev_fe = "gpt-5.3-codex-spark"
#dev_be = "gpt-5.3-codex-spark"
#dev_fs = "gpt-5.3-codex-spark"
#qa = "gpt-5.3-codex-spark"
#uat = "gpt-5.3-codex-spark"
#maint = "gpt-5.3-codex-spark"
#ux = "gpt-5.3-codex-spark"
#deploy = "gpt-5.3-codex-spark"

[codex]
# OPTIONAL: Basisprofil fuer generierte Codex-Configs.
model = "gpt-5.3-codex-spark"
approval_policy = "never"
sandbox_mode = "danger-full-access"
model_reasoning_effort = "xhigh"

[codex.reasoning_effort]
# OPTIONAL: Agent-spezifische Reasoning-Overrides.
# default = "medium"
# po = "high"
# arch = "high"
# sec = "high"
# reqeng = "medium"
# dev_fe = "medium"
# dev_be = "medium"
# dev_fs = "medium"
# qa = "medium"
# ux = "medium"
# uat = "low"
# deploy = "low"
# maint = "low"
