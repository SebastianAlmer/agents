# ============================================================================
# Beispiel: config.local.toml (projektspezifisch)
# ============================================================================
# Diese Datei ist dein Startpunkt pro Projekt.
# Kopiere sie nach config.local.toml und passe mindestens [paths].repo_root an.
#
# Hinweis:
# - Alles, was hier fehlt, faellt auf config.defaults.toml zurueck.
# - Halte local moeglichst klein: nur echte Projekt-Overrides eintragen.
#
# Startkommandos laufen aus dem Repo-Root:
# - node setup-project.js --repo-root /abs/path
# - node po-runner.js --mode vision|intake
# - node delivery-runner.js --mode full|fast
# - node reqeng-cli.js

[paths]
# PFLICHT: Absoluter Pfad zu deinem Ziel-Repo.
repo_root = "/home/you/git/your-project"

# OPTIONAL: Wenn leer, wird <repo_root>/docs verwendet.
docs_dir = ""

# OPTIONAL: Wenn leer, wird <docs_dir>/product-operating-system verwendet.
product_vision_dir = ""

# OPTIONAL: Nur aendern, wenn du die Requirements bewusst woanders verwalten willst.
requirements_root = "./requirements"

[loops]
# Typischer Startwert fuer produktive Batches.
bundle_min_size = 10
bundle_max_size = 10

[delivery_runner]
# full = kompletter Flow mit UX/SEC/QA/UAT/DEPLOY
# fast = nur arch+dev (ohne Downstream-Gates)
default_mode = "full"

[delivery_quality]
# Strenger Qualitaetsmodus: QA/UAT muessen gruen sein vor Deploy.
strict_gate = true
require_qa_pass = true
require_uat_pass = true
route_to_dev_on_fail = true
max_fix_cycles = 3
emit_followups_on_fail = false

[po]
# Intake-Buffer fuer PO im Vision-/Intake-Betrieb.
selected_high_watermark = 10
selected_low_watermark = 0
intake_max_per_cycle = 10

[dev_routing]
# split = FE/BE/FS Routing aktiv
mode = "split"

[dev_agents]
# Welche Dev-Agenten aktiv sind.
use_fe = true
use_be = true
use_fs = true

[deploy]
# check | commit | commit_push
mode = "commit_push"

[deploy.pr]
# PR-Erstellung standardmaessig aus.
enabled = false
provider = "github"
remote = "origin"
base_branch = "main"
head_mode = "current"

[qa]
# WICHTIG: Hier projektspezifische Pflichtchecks hinterlegen, sonst kann QA
# kritische Laufzeit-/Migrationsfehler spaeter erkennen.
# Beispiel (einzeilig, da der einfache TOML-Parser hier keine mehrzeiligen Arrays nutzt):
# mandatory_checks = ["npm --prefix app run db:migrate", "npm --prefix app run test", "npm --prefix web run lint"]
mandatory_checks = []
run_checks_in_runner = true

[models]
# Modellzuordnung pro Agent (Beispielprofil).
default = "gpt-5.3-codex-spark"
po = "gpt-5.3-codex"
arch = "gpt-5.3-codex"
reqeng = "gpt-5.3-codex"
sec = "gpt-5.3-codex"
dev_fe = "gpt-5.3-codex-spark"
dev_be = "gpt-5.3-codex-spark"
dev_fs = "gpt-5.3-codex-spark"
qa = "gpt-5.3-codex-spark"
uat = "gpt-5.3-codex-spark"
maint = "gpt-5.3-codex-spark"
ux = "gpt-5.3-codex-spark"
deploy = "gpt-5.3-codex-spark"

[codex]
# Basisprofil fuer alle generierten Agent-Configs.
model = "gpt-5.3-codex-spark"
approval_policy = "never"
sandbox_mode = "danger-full-access"
model_reasoning_effort = "xhigh"
