# ============================================================================
# Beispiel: config.local.toml (projektspezifisch)
# ============================================================================
# Diese Datei ist dein Startpunkt pro Projekt.
# Kopiere sie nach config.local.toml und passe mindestens [paths].repo_root an.
#
# Hinweis:
# - Alles, was hier fehlt, faellt auf config.defaults.toml zurueck.
# - Halte local moeglichst klein: nur echte Projekt-Overrides eintragen.
#
# Startkommandos laufen aus dem Repo-Root:
# - node setup-project.js --repo-root /abs/path
# - node po-runner.js --mode vision|intake
# - node delivery-runner.js --mode full|fast|test
# - node reqeng-cli.js

[paths]
# PFLICHT: Absoluter Pfad zu deinem Ziel-Repo.
repo_root = "/home/you/git/your-project"

# OPTIONAL: Wenn leer, wird <repo_root>/docs verwendet.
docs_dir = ""

# OPTIONAL: Wenn leer, wird <docs_dir>/product-operating-system verwendet.
product_vision_dir = ""

# OPTIONAL: Nur aendern, wenn du die Requirements bewusst woanders verwalten willst.
requirements_root = "./requirements"

[loops]
# Typischer Startwert fuer produktive Batches.
bundle_min_size = 10
bundle_max_size = 10

[delivery_runner]
# full = kompletter Flow mit UX/SEC/QA/UAT/DEPLOY
# fast = nur arch+dev (ohne Downstream-Gates)
# test = Regression-Mode mit Volltest (ohne Deploy-Git-Aktionen)
default_mode = "full"

[delivery_quality]
# Strenger Qualitaetsmodus: QA/UAT muessen gruen sein vor Deploy.
strict_gate = true
require_qa_pass = true
require_uat_pass = true
route_to_dev_on_fail = true
max_fix_cycles = 3
emit_followups_on_fail = false

[e2e]
# Deterministischer Volltest:
# - mode=test: wird (je nach required_in_test_mode) als Pflicht-Gate genutzt
# - mode=full: optional am Vision-Ende (run_on_full_completion)
enabled = false
required_in_test_mode = true
run_on_full_completion = true
working_dir = ""
timeout_seconds = 1800

# Beispiel: vor Test DB sauber machen / Dienste bereitstellen.
setup_commands = []

# Beispiel: Healthchecks auf laufende Dienste.
healthcheck_commands = []

# PFLICHT bei enabled=true:
# Hier den echten deterministischen Volltest eintragen, z. B.
# test_command = "npm --prefix web exec playwright test --config=playwright.config.ts --workers=1 --retries=0"
test_command = ""

# Optionales Cleanup.
teardown_command = ""

# Optionales Test-Env.
env = ["CI=1", "TZ=UTC"]

[po]
# Intake-Buffer fuer PO im Vision-/Intake-Betrieb.
selected_high_watermark = 10
selected_low_watermark = 0
intake_max_per_cycle = 10

[dev_routing]
# split = FE/BE/FS Routing aktiv
mode = "split"

[dev_agents]
# Welche Dev-Agenten aktiv sind.
use_fe = true
use_be = true
use_fs = true

[deploy]
# check | commit | commit_push
mode = "commit_push"

[deploy.pr]
# PR-Erstellung standardmaessig aus.
enabled = false
provider = "github"
remote = "origin"
base_branch = "main"
head_mode = "current"

[release_automation]
enabled = true
base_branch = "dev"
remote = "origin"
branch_prefix = "release/bundle"
version_scope = "root"
version_command = "npm version patch --no-git-tag-version"
merge_mode = "ff-only"
tag_enabled = true
tag_prefix = "v"
auto_resolve_conflicts = true
max_conflict_fix_attempts = 1
allow_release_with_human_decision_needed = true

[qa]
# WICHTIG: Hier projektspezifische Pflichtchecks hinterlegen, sonst kann QA
# kritische Laufzeit-/Migrationsfehler spaeter erkennen.
# Beispiel (einzeilig, da der einfache TOML-Parser hier keine mehrzeiligen Arrays nutzt):
# mandatory_checks = ["npm --prefix app run db:migrate", "npm --prefix app run test", "npm --prefix web run lint"]
mandatory_checks = []
run_checks_in_runner = true
auto_fix_on_mandatory_fail = true
auto_fix_max_attempts = 1
auto_fix_commands = []
auto_fix_use_codex = true

[memory]
enabled = true
dir = ".runtime/memory"
include_in_prompt = true
update_on_auto = true
update_on_interactive = true
shared_file = "shared.md"
max_context_chars_per_file = 4000
soft_max_lines_shared = 250
soft_max_lines_agent = 180

[models]
# Modellzuordnung pro Agent (Beispielprofil).
default = "gpt-5.3-codex-spark"
po = "gpt-5.3-codex"
arch = "gpt-5.3-codex"
reqeng = "gpt-5.3-codex"
sec = "gpt-5.3-codex"
dev_fe = "gpt-5.3-codex-spark"
dev_be = "gpt-5.3-codex-spark"
dev_fs = "gpt-5.3-codex-spark"
qa = "gpt-5.3-codex-spark"
uat = "gpt-5.3-codex-spark"
maint = "gpt-5.3-codex-spark"
ux = "gpt-5.3-codex-spark"
deploy = "gpt-5.3-codex-spark"

[codex]
# Basisprofil fuer alle generierten Agent-Configs.
model = "gpt-5.3-codex-spark"
approval_policy = "never"
sandbox_mode = "danger-full-access"
model_reasoning_effort = "medium"

[codex.reasoning_effort]
default = "medium"
po = "high"
arch = "high"
sec = "high"
reqeng = "medium"
dev_fe = "medium"
dev_be = "medium"
dev_fs = "medium"
qa = "medium"
ux = "medium"
uat = "low"
deploy = "low"
maint = "low"
